Script started on 2025-12-24 13:50:54+03:00 [<not executed on terminal>]
[35m13:50:56[0m :: [repository] - index updated from http://sparrowhub.io/repo/api/v1/index
[1;36m[task run: task.bash - bash: cat /etc/os-release > os-release.txt][0m
[1;36m[task stdout][0m
>>> send request: PUT job file to http://127.0.0.1:4000/file/project/debian-demo/job/lrwhgmbfevyqkjxidzco.2323981/filename/os-release.txt
>>> file path: os-release.txt
scenario: redis
===
[1;36m[task run: task.bash - tasks/redis][0m
[1;36m[task stdout][0m
^@[35m13:51:02[0m :: Reading package lists...
[35m13:51:02[0m :: Building dependency tree...
[35m13:51:02[0m :: Reading state information...
[35m13:51:02[0m :: redis-server is already the newest version (5:6.0.16-1ubuntu1.1).
[35m13:51:03[0m :: 0 upgraded, 0 newly installed, 0 to remove and 155 not upgraded.
[35m13:51:03[0m :: Redis server v=6.0.16 sha=00000000:0 malloc=jemalloc-5.2.1 bits=64 build=e91d7986ac6d5bb6
[1;36m[task stderr][0m
[35m13:51:03[0m :: 
[35m13:51:03[0m :: WARNING: apt does not have a stable CLI interface. Use with caution in scripts.
[35m13:51:03[0m :: 
[1;36m[task check][0m
stdout match <Redis server v=6.0> [36mTrue[0m
[1;36m[task run: task.bash - tasks/redis][0m
[1;36m[task stdout][0m
|> source changed to [/tmp/redis.conf.new]
[35m13:51:03[0m :: # Redis configuration file example.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note that in order to read the configuration file, Redis must be
[35m13:51:03[0m :: # started with the file path as first argument:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # ./redis-server /path/to/redis.conf
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Note on units: when memory size is needed, it is possible to specify
[35m13:51:03[0m :: # it in the usual form of 1k 5GB 4M and so forth:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 1k => 1000 bytes
[35m13:51:03[0m :: # 1kb => 1024 bytes
[35m13:51:03[0m :: # 1m => 1000000 bytes
[35m13:51:03[0m :: # 1mb => 1024*1024 bytes
[35m13:51:03[0m :: # 1g => 1000000000 bytes
[35m13:51:03[0m :: # 1gb => 1024*1024*1024 bytes
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # units are case insensitive so 1GB 1Gb 1gB are all the same.
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################## INCLUDES ###################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Include one or more other config files here.  This is useful if you
[35m13:51:03[0m :: # have a standard template that goes to all Redis servers but also need
[35m13:51:03[0m :: # to customize a few per-server settings.  Include files can include
[35m13:51:03[0m :: # other files, so use this wisely.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note that option "include" won't be rewritten by command "CONFIG REWRITE"
[35m13:51:03[0m :: # from admin or Redis Sentinel. Since Redis always uses the last processed
[35m13:51:03[0m :: # line as value of a configuration directive, you'd better put includes
[35m13:51:03[0m :: # at the beginning of this file to avoid overwriting config change at runtime.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # If instead you are interested in using includes to override configuration
[35m13:51:03[0m :: # options, it is better to use include as the last line.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # include /path/to/local.conf
[35m13:51:03[0m :: # include /path/to/other.conf
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################## MODULES #####################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Load modules at startup. If the server is not able to load modules
[35m13:51:03[0m :: # it will abort. It is possible to use multiple loadmodule directives.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # loadmodule /path/to/my_module.so
[35m13:51:03[0m :: # loadmodule /path/to/other_module.so
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################## NETWORK #####################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default, if no "bind" configuration directive is specified, Redis listens
[35m13:51:03[0m :: # for connections from all available network interfaces on the host machine.
[35m13:51:03[0m :: # It is possible to listen to just one or multiple selected interfaces using
[35m13:51:03[0m :: # the "bind" configuration directive, followed by one or more IP addresses.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Examples:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # bind 192.168.1.100 10.0.0.1
[35m13:51:03[0m :: # bind 127.0.0.1 ::1
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the
[35m13:51:03[0m :: # internet, binding to all the interfaces is dangerous and will expose the
[35m13:51:03[0m :: # instance to everybody on the internet. So by default we uncomment the
[35m13:51:03[0m :: # following bind directive, that will force Redis to listen only on the
[35m13:51:03[0m :: # IPv4 loopback interface address (this means Redis will only be able to
[35m13:51:03[0m :: # accept client connections from the same host that it is running on).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES
[35m13:51:03[0m :: # JUST COMMENT OUT THE FOLLOWING LINE.
[35m13:51:03[0m :: # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[35m13:51:03[0m :: bind 127.0.0.1 ::1
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Protected mode is a layer of security protection, in order to avoid that
[35m13:51:03[0m :: # Redis instances left open on the internet are accessed and exploited.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # When protected mode is on and if:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 1) The server is not binding explicitly to a set of addresses using the
[35m13:51:03[0m :: #    "bind" directive.
[35m13:51:03[0m :: # 2) No password is configured.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The server only accepts connections from clients connecting from the
[35m13:51:03[0m :: # IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain
[35m13:51:03[0m :: # sockets.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # By default protected mode is enabled. You should disable it only if
[35m13:51:03[0m :: # you are sure you want clients from other hosts to connect to Redis
[35m13:51:03[0m :: # even if no authentication is configured, nor a specific set of interfaces
[35m13:51:03[0m :: # are explicitly listed using the "bind" directive.
[35m13:51:03[0m :: protected-mode yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Accept connections on the specified port, default is 6379 (IANA #815344).
[35m13:51:03[0m :: # If port 0 is specified Redis will not listen on a TCP socket.
[35m13:51:03[0m :: port 6379
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # TCP listen() backlog.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # In high requests-per-second environments you need a high backlog in order
[35m13:51:03[0m :: # to avoid slow clients connection issues. Note that the Linux kernel
[35m13:51:03[0m :: # will silently truncate it to the value of /proc/sys/net/core/somaxconn so
[35m13:51:03[0m :: # make sure to raise both the value of somaxconn and tcp_max_syn_backlog
[35m13:51:03[0m :: # in order to get the desired effect.
[35m13:51:03[0m :: tcp-backlog 511
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Unix socket.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Specify the path for the Unix socket that will be used to listen for
[35m13:51:03[0m :: # incoming connections. There is no default, so Redis will not listen
[35m13:51:03[0m :: # on a unix socket when not specified.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # unixsocket /var/run/redis/redis-server.sock
[35m13:51:03[0m :: # unixsocketperm 700
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Close the connection after a client is idle for N seconds (0 to disable)
[35m13:51:03[0m :: timeout 0
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # TCP keepalive.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
[35m13:51:03[0m :: # of communication. This is useful for two reasons:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 1) Detect dead peers.
[35m13:51:03[0m :: # 2) Force network equipment in the middle to consider the connection to be
[35m13:51:03[0m :: #    alive.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # On Linux, the specified value (in seconds) is the period used to send ACKs.
[35m13:51:03[0m :: # Note that to close the connection the double of the time is needed.
[35m13:51:03[0m :: # On other kernels the period depends on the kernel configuration.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # A reasonable value for this option is 300 seconds, which is the new
[35m13:51:03[0m :: # Redis default starting with Redis 3.2.1.
[35m13:51:03[0m :: tcp-keepalive 300
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################# TLS/SSL #####################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default, TLS/SSL is disabled. To enable it, the "tls-port" configuration
[35m13:51:03[0m :: # directive can be used to define TLS-listening ports. To enable TLS on the
[35m13:51:03[0m :: # default port, use:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # port 0
[35m13:51:03[0m :: # tls-port 6379
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Configure a X.509 certificate and private key to use for authenticating the
[35m13:51:03[0m :: # server to connected clients, masters or cluster peers.  These files should be
[35m13:51:03[0m :: # PEM formatted.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-cert-file redis.crt 
[35m13:51:03[0m :: # tls-key-file redis.key
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-dh-params-file redis.dh
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Configure a CA certificate(s) bundle or directory to authenticate TLS/SSL
[35m13:51:03[0m :: # clients and peers.  Redis requires an explicit configuration of at least one
[35m13:51:03[0m :: # of these, and will not implicitly use the system wide configuration.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-ca-cert-file ca.crt
[35m13:51:03[0m :: # tls-ca-cert-dir /etc/ssl/certs
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default, clients (including replica servers) on a TLS port are required
[35m13:51:03[0m :: # to authenticate using valid client side certificates.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # If "no" is specified, client certificates are not required and not accepted.
[35m13:51:03[0m :: # If "optional" is specified, client certificates are accepted and must be
[35m13:51:03[0m :: # valid if provided, but are not required.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-auth-clients no
[35m13:51:03[0m :: # tls-auth-clients optional
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default, a Redis replica does not attempt to establish a TLS connection
[35m13:51:03[0m :: # with its master.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Use the following directive to enable TLS on replication links.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-replication yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default, the Redis Cluster bus uses a plain TCP connection. To enable
[35m13:51:03[0m :: # TLS for the bus protocol, use the following directive:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-cluster yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Explicitly specify TLS versions to support. Allowed values are case insensitive
[35m13:51:03[0m :: # and include "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3" (OpenSSL >= 1.1.1) or
[35m13:51:03[0m :: # any combination. To enable only TLSv1.2 and TLSv1.3, use:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-protocols "TLSv1.2 TLSv1.3"
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information
[35m13:51:03[0m :: # about the syntax of this string.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note: this configuration applies only to <= TLSv1.2.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-ciphers DEFAULT:!MEDIUM
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more
[35m13:51:03[0m :: # information about the syntax of this string, and specifically for TLSv1.3
[35m13:51:03[0m :: # ciphersuites.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-ciphersuites TLS_CHACHA20_POLY1305_SHA256
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # When choosing a cipher, use the server's preference instead of the client
[35m13:51:03[0m :: # preference. By default, the server follows the client's preference.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-prefer-server-ciphers yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default, TLS session caching is enabled to allow faster and less expensive
[35m13:51:03[0m :: # reconnections by clients that support it. Use the following directive to disable
[35m13:51:03[0m :: # caching.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-session-caching no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Change the default number of TLS sessions cached. A zero value sets the cache
[35m13:51:03[0m :: # to unlimited size. The default size is 20480.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-session-cache-size 5000
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Change the default timeout of cached TLS sessions. The default timeout is 300
[35m13:51:03[0m :: # seconds.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tls-session-cache-timeout 60
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################# GENERAL #####################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default Redis does not run as a daemon. Use 'yes' if you need it.
[35m13:51:03[0m :: # Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
[35m13:51:03[0m :: daemonize yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # If you run Redis from upstart or systemd, Redis can interact with your
[35m13:51:03[0m :: # supervision tree. Options:
[35m13:51:03[0m :: #   supervised no      - no supervision interaction
[35m13:51:03[0m :: #   supervised upstart - signal upstart by putting Redis into SIGSTOP mode
[35m13:51:03[0m :: #                        requires "expect stop" in your upstart job config
[35m13:51:03[0m :: #   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
[35m13:51:03[0m :: #   supervised auto    - detect upstart or systemd method based on
[35m13:51:03[0m :: #                        UPSTART_JOB or NOTIFY_SOCKET environment variables
[35m13:51:03[0m :: # Note: these supervision methods only signal "process is ready."
[35m13:51:03[0m :: #       They do not enable continuous pings back to your supervisor.
[35m13:51:03[0m :: supervised no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # If a pid file is specified, Redis writes it where specified at startup
[35m13:51:03[0m :: # and removes it at exit.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # When the server runs non daemonized, no pid file is created if none is
[35m13:51:03[0m :: # specified in the configuration. When the server is daemonized, the pid file
[35m13:51:03[0m :: # is used even if not specified, defaulting to "/var/run/redis.pid".
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Creating a pid file is best effort: if Redis is not able to create it
[35m13:51:03[0m :: # nothing bad happens, the server will start and run normally.
[35m13:51:03[0m :: pidfile /var/run/redis/redis-server.pid
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Specify the server verbosity level.
[35m13:51:03[0m :: # This can be one of:
[35m13:51:03[0m :: # debug (a lot of information, useful for development/testing)
[35m13:51:03[0m :: # verbose (many rarely useful info, but not a mess like the debug level)
[35m13:51:03[0m :: # notice (moderately verbose, what you want in production probably)
[35m13:51:03[0m :: # warning (only very important / critical messages are logged)
[35m13:51:03[0m :: loglevel notice
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Specify the log file name. Also the empty string can be used to force
[35m13:51:03[0m :: # Redis to log on the standard output. Note that if you use standard
[35m13:51:03[0m :: # output for logging but daemonize, logs will be sent to /dev/null
[35m13:51:03[0m :: logfile /var/log/redis/redis-server.log
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # To enable logging to the system logger, just set 'syslog-enabled' to yes,
[35m13:51:03[0m :: # and optionally update the other syslog parameters to suit your needs.
[35m13:51:03[0m :: # syslog-enabled no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Specify the syslog identity.
[35m13:51:03[0m :: # syslog-ident redis
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
[35m13:51:03[0m :: # syslog-facility local0
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Set the number of databases. The default database is DB 0, you can select
[35m13:51:03[0m :: # a different one on a per-connection basis using SELECT <dbid> where
[35m13:51:03[0m :: # dbid is a number between 0 and 'databases'-1
[35m13:51:03[0m :: databases 16
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default Redis shows an ASCII art logo only when started to log to the
[35m13:51:03[0m :: # standard output and if the standard output is a TTY. Basically this means
[35m13:51:03[0m :: # that normally a logo is displayed only in interactive sessions.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # However it is possible to force the pre-4.0 behavior and always show a
[35m13:51:03[0m :: # ASCII art logo in startup logs by setting the following option to yes.
[35m13:51:03[0m :: always-show-logo yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################ SNAPSHOTTING  ################################
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Save the DB on disk:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   save <seconds> <changes>
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   Will save the DB if both the given number of seconds and the given
[35m13:51:03[0m :: #   number of write operations against the DB occurred.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   In the example below the behavior will be to save:
[35m13:51:03[0m :: #   after 900 sec (15 min) if at least 1 key changed
[35m13:51:03[0m :: #   after 300 sec (5 min) if at least 10 keys changed
[35m13:51:03[0m :: #   after 60 sec if at least 10000 keys changed
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   Note: you can disable saving completely by commenting out all "save" lines.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   It is also possible to remove all the previously configured save
[35m13:51:03[0m :: #   points by adding a save directive with a single empty string argument
[35m13:51:03[0m :: #   like in the following example:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   save ""
[35m13:51:03[0m :: 
[35m13:51:03[0m :: save 900 1
[35m13:51:03[0m :: save 300 10
[35m13:51:03[0m :: save 60 10000
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default Redis will stop accepting writes if RDB snapshots are enabled
[35m13:51:03[0m :: # (at least one save point) and the latest background save failed.
[35m13:51:03[0m :: # This will make the user aware (in a hard way) that data is not persisting
[35m13:51:03[0m :: # on disk properly, otherwise chances are that no one will notice and some
[35m13:51:03[0m :: # disaster will happen.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # If the background saving process will start working again Redis will
[35m13:51:03[0m :: # automatically allow writes again.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # However if you have setup your proper monitoring of the Redis server
[35m13:51:03[0m :: # and persistence, you may want to disable this feature so that Redis will
[35m13:51:03[0m :: # continue to work as usual even if there are problems with disk,
[35m13:51:03[0m :: # permissions, and so forth.
[35m13:51:03[0m :: stop-writes-on-bgsave-error yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Compress string objects using LZF when dump .rdb databases?
[35m13:51:03[0m :: # By default compression is enabled as it's almost always a win.
[35m13:51:03[0m :: # If you want to save some CPU in the saving child set it to 'no' but
[35m13:51:03[0m :: # the dataset will likely be bigger if you have compressible values or keys.
[35m13:51:03[0m :: rdbcompression yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
[35m13:51:03[0m :: # This makes the format more resistant to corruption but there is a performance
[35m13:51:03[0m :: # hit to pay (around 10%) when saving and loading RDB files, so you can disable it
[35m13:51:03[0m :: # for maximum performances.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # RDB files created with checksum disabled have a checksum of zero that will
[35m13:51:03[0m :: # tell the loading code to skip the check.
[35m13:51:03[0m :: rdbchecksum yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # The filename where to dump the DB
[35m13:51:03[0m :: dbfilename dump.rdb
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Remove RDB files used by replication in instances without persistence
[35m13:51:03[0m :: # enabled. By default this option is disabled, however there are environments
[35m13:51:03[0m :: # where for regulations or other security concerns, RDB files persisted on
[35m13:51:03[0m :: # disk by masters in order to feed replicas, or stored on disk by replicas
[35m13:51:03[0m :: # in order to load them for the initial synchronization, should be deleted
[35m13:51:03[0m :: # ASAP. Note that this option ONLY WORKS in instances that have both AOF
[35m13:51:03[0m :: # and RDB persistence disabled, otherwise is completely ignored.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # An alternative (and sometimes better) way to obtain the same effect is
[35m13:51:03[0m :: # to use diskless replication on both master and replicas instances. However
[35m13:51:03[0m :: # in the case of replicas, diskless is not always an option.
[35m13:51:03[0m :: rdb-del-sync-files no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # The working directory.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The DB will be written inside this directory, with the filename specified
[35m13:51:03[0m :: # above using the 'dbfilename' configuration directive.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The Append Only File will also be created inside this directory.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note that you must specify a directory here, not a file name.
[35m13:51:03[0m :: dir /var/lib/redis
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################# REPLICATION #################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Master-Replica replication. Use replicaof to make a Redis instance a copy of
[35m13:51:03[0m :: # another Redis server. A few things to understand ASAP about Redis replication.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   +------------------+      +---------------+
[35m13:51:03[0m :: #   |      Master      | ---> |    Replica    |
[35m13:51:03[0m :: #   | (receive writes) |      |  (exact copy) |
[35m13:51:03[0m :: #   +------------------+      +---------------+
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 1) Redis replication is asynchronous, but you can configure a master to
[35m13:51:03[0m :: #    stop accepting writes if it appears to be not connected with at least
[35m13:51:03[0m :: #    a given number of replicas.
[35m13:51:03[0m :: # 2) Redis replicas are able to perform a partial resynchronization with the
[35m13:51:03[0m :: #    master if the replication link is lost for a relatively small amount of
[35m13:51:03[0m :: #    time. You may want to configure the replication backlog size (see the next
[35m13:51:03[0m :: #    sections of this file) with a sensible value depending on your needs.
[35m13:51:03[0m :: # 3) Replication is automatic and does not need user intervention. After a
[35m13:51:03[0m :: #    network partition replicas automatically try to reconnect to masters
[35m13:51:03[0m :: #    and resynchronize with them.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # replicaof <masterip> <masterport>
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # If the master is password protected (using the "requirepass" configuration
[35m13:51:03[0m :: # directive below) it is possible to tell the replica to authenticate before
[35m13:51:03[0m :: # starting the replication synchronization process, otherwise the master will
[35m13:51:03[0m :: # refuse the replica request.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # masterauth <master-password>
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # However this is not enough if you are using Redis ACLs (for Redis version
[35m13:51:03[0m :: # 6 or greater), and the default user is not capable of running the PSYNC
[35m13:51:03[0m :: # command and/or other commands needed for replication. In this case it's
[35m13:51:03[0m :: # better to configure a special user to use with replication, and specify the
[35m13:51:03[0m :: # masteruser configuration as such:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # masteruser <username>
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # When masteruser is specified, the replica will authenticate against its
[35m13:51:03[0m :: # master using the new AUTH form: AUTH <username> <password>.
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # When a replica loses its connection with the master, or when the replication
[35m13:51:03[0m :: # is still in progress, the replica can act in two different ways:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
[35m13:51:03[0m :: #    still reply to client requests, possibly with out of date data, or the
[35m13:51:03[0m :: #    data set may just be empty if this is the first synchronization.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 2) If replica-serve-stale-data is set to 'no' the replica will reply with
[35m13:51:03[0m :: #    an error "SYNC with master in progress" to all commands except:
[35m13:51:03[0m :: #    INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG, SUBSCRIBE,
[35m13:51:03[0m :: #    UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST,
[35m13:51:03[0m :: #    HOST and LATENCY.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: replica-serve-stale-data yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # You can configure a replica instance to accept writes or not. Writing against
[35m13:51:03[0m :: # a replica instance may be useful to store some ephemeral data (because data
[35m13:51:03[0m :: # written on a replica will be easily deleted after resync with the master) but
[35m13:51:03[0m :: # may also cause problems if clients are writing to it because of a
[35m13:51:03[0m :: # misconfiguration.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Since Redis 2.6 by default replicas are read-only.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note: read only replicas are not designed to be exposed to untrusted clients
[35m13:51:03[0m :: # on the internet. It's just a protection layer against misuse of the instance.
[35m13:51:03[0m :: # Still a read only replica exports by default all the administrative commands
[35m13:51:03[0m :: # such as CONFIG, DEBUG, and so forth. To a limited extent you can improve
[35m13:51:03[0m :: # security of read only replicas using 'rename-command' to shadow all the
[35m13:51:03[0m :: # administrative / dangerous commands.
[35m13:51:03[0m :: replica-read-only yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Replication SYNC strategy: disk or socket.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # New replicas and reconnecting replicas that are not able to continue the
[35m13:51:03[0m :: # replication process just receiving differences, need to do what is called a
[35m13:51:03[0m :: # "full synchronization". An RDB file is transmitted from the master to the
[35m13:51:03[0m :: # replicas.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The transmission can happen in two different ways:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 1) Disk-backed: The Redis master creates a new process that writes the RDB
[35m13:51:03[0m :: #                 file on disk. Later the file is transferred by the parent
[35m13:51:03[0m :: #                 process to the replicas incrementally.
[35m13:51:03[0m :: # 2) Diskless: The Redis master creates a new process that directly writes the
[35m13:51:03[0m :: #              RDB file to replica sockets, without touching the disk at all.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # With disk-backed replication, while the RDB file is generated, more replicas
[35m13:51:03[0m :: # can be queued and served with the RDB file as soon as the current child
[35m13:51:03[0m :: # producing the RDB file finishes its work. With diskless replication instead
[35m13:51:03[0m :: # once the transfer starts, new replicas arriving will be queued and a new
[35m13:51:03[0m :: # transfer will start when the current one terminates.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # When diskless replication is used, the master waits a configurable amount of
[35m13:51:03[0m :: # time (in seconds) before starting the transfer in the hope that multiple
[35m13:51:03[0m :: # replicas will arrive and the transfer can be parallelized.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # With slow disks and fast (large bandwidth) networks, diskless replication
[35m13:51:03[0m :: # works better.
[35m13:51:03[0m :: repl-diskless-sync no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # When diskless replication is enabled, it is possible to configure the delay
[35m13:51:03[0m :: # the server waits in order to spawn the child that transfers the RDB via socket
[35m13:51:03[0m :: # to the replicas.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # This is important since once the transfer starts, it is not possible to serve
[35m13:51:03[0m :: # new replicas arriving, that will be queued for the next RDB transfer, so the
[35m13:51:03[0m :: # server waits a delay in order to let more replicas arrive.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The delay is specified in seconds, and by default is 5 seconds. To disable
[35m13:51:03[0m :: # it entirely just set it to 0 seconds and the transfer will start ASAP.
[35m13:51:03[0m :: repl-diskless-sync-delay 5
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # -----------------------------------------------------------------------------
[35m13:51:03[0m :: # WARNING: RDB diskless load is experimental. Since in this setup the replica
[35m13:51:03[0m :: # does not immediately store an RDB on disk, it may cause data loss during
[35m13:51:03[0m :: # failovers. RDB diskless load + Redis modules not handling I/O reads may also
[35m13:51:03[0m :: # cause Redis to abort in case of I/O errors during the initial synchronization
[35m13:51:03[0m :: # stage with the master. Use only if your do what you are doing.
[35m13:51:03[0m :: # -----------------------------------------------------------------------------
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Replica can load the RDB it reads from the replication link directly from the
[35m13:51:03[0m :: # socket, or store the RDB to a file and read that file after it was completely
[35m13:51:03[0m :: # received from the master.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # In many cases the disk is slower than the network, and storing and loading
[35m13:51:03[0m :: # the RDB file may increase replication time (and even increase the master's
[35m13:51:03[0m :: # Copy on Write memory and salve buffers).
[35m13:51:03[0m :: # However, parsing the RDB file directly from the socket may mean that we have
[35m13:51:03[0m :: # to flush the contents of the current database before the full rdb was
[35m13:51:03[0m :: # received. For this reason we have the following options:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # "disabled"    - Don't use diskless load (store the rdb file to the disk first)
[35m13:51:03[0m :: # "on-empty-db" - Use diskless load only when it is completely safe.
[35m13:51:03[0m :: # "swapdb"      - Keep a copy of the current db contents in RAM while parsing
[35m13:51:03[0m :: #                 the data directly from the socket. note that this requires
[35m13:51:03[0m :: #                 sufficient memory, if you don't have it, you risk an OOM kill.
[35m13:51:03[0m :: repl-diskless-load disabled
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Replicas send PINGs to server in a predefined interval. It's possible to
[35m13:51:03[0m :: # change this interval with the repl_ping_replica_period option. The default
[35m13:51:03[0m :: # value is 10 seconds.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # repl-ping-replica-period 10
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # The following option sets the replication timeout for:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 1) Bulk transfer I/O during SYNC, from the point of view of replica.
[35m13:51:03[0m :: # 2) Master timeout from the point of view of replicas (data, pings).
[35m13:51:03[0m :: # 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # It is important to make sure that this value is greater than the value
[35m13:51:03[0m :: # specified for repl-ping-replica-period otherwise a timeout will be detected
[35m13:51:03[0m :: # every time there is low traffic between the master and the replica. The default
[35m13:51:03[0m :: # value is 60 seconds.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # repl-timeout 60
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Disable TCP_NODELAY on the replica socket after SYNC?
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # If you select "yes" Redis will use a smaller number of TCP packets and
[35m13:51:03[0m :: # less bandwidth to send data to replicas. But this can add a delay for
[35m13:51:03[0m :: # the data to appear on the replica side, up to 40 milliseconds with
[35m13:51:03[0m :: # Linux kernels using a default configuration.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # If you select "no" the delay for data to appear on the replica side will
[35m13:51:03[0m :: # be reduced but more bandwidth will be used for replication.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # By default we optimize for low latency, but in very high traffic conditions
[35m13:51:03[0m :: # or when the master and replicas are many hops away, turning this to "yes" may
[35m13:51:03[0m :: # be a good idea.
[35m13:51:03[0m :: repl-disable-tcp-nodelay no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Set the replication backlog size. The backlog is a buffer that accumulates
[35m13:51:03[0m :: # replica data when replicas are disconnected for some time, so that when a
[35m13:51:03[0m :: # replica wants to reconnect again, often a full resync is not needed, but a
[35m13:51:03[0m :: # partial resync is enough, just passing the portion of data the replica
[35m13:51:03[0m :: # missed while disconnected.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The bigger the replication backlog, the longer the replica can endure the
[35m13:51:03[0m :: # disconnect and later be able to perform a partial resynchronization.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The backlog is only allocated if there is at least one replica connected.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # repl-backlog-size 1mb
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # After a master has no connected replicas for some time, the backlog will be
[35m13:51:03[0m :: # freed. The following option configures the amount of seconds that need to
[35m13:51:03[0m :: # elapse, starting from the time the last replica disconnected, for the backlog
[35m13:51:03[0m :: # buffer to be freed.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note that replicas never free the backlog for timeout, since they may be
[35m13:51:03[0m :: # promoted to masters later, and should be able to correctly "partially
[35m13:51:03[0m :: # resynchronize" with other replicas: hence they should always accumulate backlog.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # A value of 0 means to never release the backlog.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # repl-backlog-ttl 3600
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # The replica priority is an integer number published by Redis in the INFO
[35m13:51:03[0m :: # output. It is used by Redis Sentinel in order to select a replica to promote
[35m13:51:03[0m :: # into a master if the master is no longer working correctly.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # A replica with a low priority number is considered better for promotion, so
[35m13:51:03[0m :: # for instance if there are three replicas with priority 10, 100, 25 Sentinel
[35m13:51:03[0m :: # will pick the one with priority 10, that is the lowest.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # However a special priority of 0 marks the replica as not able to perform the
[35m13:51:03[0m :: # role of master, so a replica with priority of 0 will never be selected by
[35m13:51:03[0m :: # Redis Sentinel for promotion.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # By default the priority is 100.
[35m13:51:03[0m :: replica-priority 100
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # It is possible for a master to stop accepting writes if there are less than
[35m13:51:03[0m :: # N replicas connected, having a lag less or equal than M seconds.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The N replicas need to be in "online" state.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The lag in seconds, that must be <= the specified value, is calculated from
[35m13:51:03[0m :: # the last ping received from the replica, that is usually sent every second.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # This option does not GUARANTEE that N replicas will accept the write, but
[35m13:51:03[0m :: # will limit the window of exposure for lost writes in case not enough replicas
[35m13:51:03[0m :: # are available, to the specified number of seconds.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # For example to require at least 3 replicas with a lag <= 10 seconds use:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # min-replicas-to-write 3
[35m13:51:03[0m :: # min-replicas-max-lag 10
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Setting one or the other to 0 disables the feature.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # By default min-replicas-to-write is set to 0 (feature disabled) and
[35m13:51:03[0m :: # min-replicas-max-lag is set to 10.
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # A Redis master is able to list the address and port of the attached
[35m13:51:03[0m :: # replicas in different ways. For example the "INFO replication" section
[35m13:51:03[0m :: # offers this information, which is used, among other tools, by
[35m13:51:03[0m :: # Redis Sentinel in order to discover replica instances.
[35m13:51:03[0m :: # Another place where this info is available is in the output of the
[35m13:51:03[0m :: # "ROLE" command of a master.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The listed IP address and port normally reported by a replica is
[35m13:51:03[0m :: # obtained in the following way:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   IP: The address is auto detected by checking the peer address
[35m13:51:03[0m :: #   of the socket used by the replica to connect with the master.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   Port: The port is communicated by the replica during the replication
[35m13:51:03[0m :: #   handshake, and is normally the port that the replica is using to
[35m13:51:03[0m :: #   listen for connections.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # However when port forwarding or Network Address Translation (NAT) is
[35m13:51:03[0m :: # used, the replica may actually be reachable via different IP and port
[35m13:51:03[0m :: # pairs. The following two options can be used by a replica in order to
[35m13:51:03[0m :: # report to its master a specific set of IP and port, so that both INFO
[35m13:51:03[0m :: # and ROLE will report those values.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # There is no need to use both the options if you need to override just
[35m13:51:03[0m :: # the port or the IP address.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # replica-announce-ip 5.5.5.5
[35m13:51:03[0m :: # replica-announce-port 1234
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ############################### KEYS TRACKING #################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Redis implements server assisted support for client side caching of values.
[35m13:51:03[0m :: # This is implemented using an invalidation table that remembers, using
[35m13:51:03[0m :: # 16 millions of slots, what clients may have certain subsets of keys. In turn
[35m13:51:03[0m :: # this is used in order to send invalidation messages to clients. Please
[35m13:51:03[0m :: # check this page to understand more about the feature:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   https://redis.io/topics/client-side-caching
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # When tracking is enabled for a client, all the read only queries are assumed
[35m13:51:03[0m :: # to be cached: this will force Redis to store information in the invalidation
[35m13:51:03[0m :: # table. When keys are modified, such information is flushed away, and
[35m13:51:03[0m :: # invalidation messages are sent to the clients. However if the workload is
[35m13:51:03[0m :: # heavily dominated by reads, Redis could use more and more memory in order
[35m13:51:03[0m :: # to track the keys fetched by many clients.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # For this reason it is possible to configure a maximum fill value for the
[35m13:51:03[0m :: # invalidation table. By default it is set to 1M of keys, and once this limit
[35m13:51:03[0m :: # is reached, Redis will start to evict keys in the invalidation table
[35m13:51:03[0m :: # even if they were not modified, just to reclaim memory: this will in turn
[35m13:51:03[0m :: # force the clients to invalidate the cached values. Basically the table
[35m13:51:03[0m :: # maximum size is a trade off between the memory you want to spend server
[35m13:51:03[0m :: # side to track information about who cached what, and the ability of clients
[35m13:51:03[0m :: # to retain cached objects in memory.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # If you set the value to 0, it means there are no limits, and Redis will
[35m13:51:03[0m :: # retain as many keys as needed in the invalidation table.
[35m13:51:03[0m :: # In the "stats" INFO section, you can find information about the number of
[35m13:51:03[0m :: # keys in the invalidation table at every given moment.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note: when key tracking is used in broadcasting mode, no memory is used
[35m13:51:03[0m :: # in the server side so this setting is useless.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # tracking-table-max-keys 1000000
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################## SECURITY ###################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Warning: since Redis is pretty fast, an outside user can try up to
[35m13:51:03[0m :: # 1 million passwords per second against a modern box. This means that you
[35m13:51:03[0m :: # should use very strong passwords, otherwise they will be very easy to break.
[35m13:51:03[0m :: # Note that because the password is really a shared secret between the client
[35m13:51:03[0m :: # and the server, and should not be memorized by any human, the password
[35m13:51:03[0m :: # can be easily a long string from /dev/urandom or whatever, so by using a
[35m13:51:03[0m :: # long and unguessable password no brute force attack will be possible.
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Redis ACL users are defined in the following format:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   user <username> ... acl rules ...
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # For example:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   user worker +@list +@connection ~jobs:* on >ffa9203c493aa99
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The special username "default" is used for new connections. If this user
[35m13:51:03[0m :: # has the "nopass" rule, then new connections will be immediately authenticated
[35m13:51:03[0m :: # as the "default" user without the need of any password provided via the
[35m13:51:03[0m :: # AUTH command. Otherwise if the "default" user is not flagged with "nopass"
[35m13:51:03[0m :: # the connections will start in not authenticated state, and will require
[35m13:51:03[0m :: # AUTH (or the HELLO command AUTH option) in order to be authenticated and
[35m13:51:03[0m :: # start to work.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The ACL rules that describe what a user can do are the following:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #  on           Enable the user: it is possible to authenticate as this user.
[35m13:51:03[0m :: #  off          Disable the user: it's no longer possible to authenticate
[35m13:51:03[0m :: #               with this user, however the already authenticated connections
[35m13:51:03[0m :: #               will still work.
[35m13:51:03[0m :: #  +<command>   Allow the execution of that command
[35m13:51:03[0m :: #  -<command>   Disallow the execution of that command
[35m13:51:03[0m :: #  +@<category> Allow the execution of all the commands in such category
[35m13:51:03[0m :: #               with valid categories are like @admin, @set, @sortedset, ...
[35m13:51:03[0m :: #               and so forth, see the full list in the server.c file where
[35m13:51:03[0m :: #               the Redis command table is described and defined.
[35m13:51:03[0m :: #               The special category @all means all the commands, but currently
[35m13:51:03[0m :: #               present in the server, and that will be loaded in the future
[35m13:51:03[0m :: #               via modules.
[35m13:51:03[0m :: #  +<command>|subcommand    Allow a specific subcommand of an otherwise
[35m13:51:03[0m :: #                           disabled command. Note that this form is not
[35m13:51:03[0m :: #                           allowed as negative like -DEBUG|SEGFAULT, but
[35m13:51:03[0m :: #                           only additive starting with "+".
[35m13:51:03[0m :: #  allcommands  Alias for +@all. Note that it implies the ability to execute
[35m13:51:03[0m :: #               all the future commands loaded via the modules system.
[35m13:51:03[0m :: #  nocommands   Alias for -@all.
[35m13:51:03[0m :: #  ~<pattern>   Add a pattern of keys that can be mentioned as part of
[35m13:51:03[0m :: #               commands. For instance ~* allows all the keys. The pattern
[35m13:51:03[0m :: #               is a glob-style pattern like the one of KEYS.
[35m13:51:03[0m :: #               It is possible to specify multiple patterns.
[35m13:51:03[0m :: #  allkeys      Alias for ~*
[35m13:51:03[0m :: #  resetkeys    Flush the list of allowed keys patterns.
[35m13:51:03[0m :: #  ><password>  Add this password to the list of valid password for the user.
[35m13:51:03[0m :: #               For example >mypass will add "mypass" to the list.
[35m13:51:03[0m :: #               This directive clears the "nopass" flag (see later).
[35m13:51:03[0m :: #  <<password>  Remove this password from the list of valid passwords.
[35m13:51:03[0m :: #  nopass       All the set passwords of the user are removed, and the user
[35m13:51:03[0m :: #               is flagged as requiring no password: it means that every
[35m13:51:03[0m :: #               password will work against this user. If this directive is
[35m13:51:03[0m :: #               used for the default user, every new connection will be
[35m13:51:03[0m :: #               immediately authenticated with the default user without
[35m13:51:03[0m :: #               any explicit AUTH command required. Note that the "resetpass"
[35m13:51:03[0m :: #               directive will clear this condition.
[35m13:51:03[0m :: #  resetpass    Flush the list of allowed passwords. Moreover removes the
[35m13:51:03[0m :: #               "nopass" status. After "resetpass" the user has no associated
[35m13:51:03[0m :: #               passwords and there is no way to authenticate without adding
[35m13:51:03[0m :: #               some password (or setting it as "nopass" later).
[35m13:51:03[0m :: #  reset        Performs the following actions: resetpass, resetkeys, off,
[35m13:51:03[0m :: #               -@all. The user returns to the same state it has immediately
[35m13:51:03[0m :: #               after its creation.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # ACL rules can be specified in any order: for instance you can start with
[35m13:51:03[0m :: # passwords, then flags, or key patterns. However note that the additive
[35m13:51:03[0m :: # and subtractive rules will CHANGE MEANING depending on the ordering.
[35m13:51:03[0m :: # For instance see the following example:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   user alice on +@all -DEBUG ~* >somepassword
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # This will allow "alice" to use all the commands with the exception of the
[35m13:51:03[0m :: # DEBUG command, since +@all added all the commands to the set of the commands
[35m13:51:03[0m :: # alice can use, and later DEBUG was removed. However if we invert the order
[35m13:51:03[0m :: # of two ACL rules the result will be different:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #   user alice on -DEBUG +@all ~* >somepassword
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Now DEBUG was removed when alice had yet no commands in the set of allowed
[35m13:51:03[0m :: # commands, later all the commands are added, so the user will be able to
[35m13:51:03[0m :: # execute everything.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Basically ACL rules are processed left-to-right.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # For more information about ACL configuration please refer to
[35m13:51:03[0m :: # the Redis web site at https://redis.io/topics/acl
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # ACL LOG
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The ACL Log tracks failed commands and authentication events associated
[35m13:51:03[0m :: # with ACLs. The ACL Log is useful to troubleshoot failed commands blocked 
[35m13:51:03[0m :: # by ACLs. The ACL Log is stored in memory. You can reclaim memory with 
[35m13:51:03[0m :: # ACL LOG RESET. Define the maximum entry length of the ACL Log below.
[35m13:51:03[0m :: acllog-max-len 128
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Using an external ACL file
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Instead of configuring users here in this file, it is possible to use
[35m13:51:03[0m :: # a stand-alone file just listing users. The two methods cannot be mixed:
[35m13:51:03[0m :: # if you configure users here and at the same time you activate the external
[35m13:51:03[0m :: # ACL file, the server will refuse to start.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The format of the external ACL user file is exactly the same as the
[35m13:51:03[0m :: # format that is used inside redis.conf to describe users.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # aclfile /etc/redis/users.acl
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # IMPORTANT NOTE: starting with Redis 6 "requirepass" is just a compatibility
[35m13:51:03[0m :: # layer on top of the new ACL system. The option effect will be just setting
[35m13:51:03[0m :: # the password for the default user. Clients will still authenticate using
[35m13:51:03[0m :: # AUTH <password> as usually, or more explicitly with AUTH default <password>
[35m13:51:03[0m :: # if they follow the new protocol: both will work.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # requirepass foobared
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Command renaming (DEPRECATED).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # ------------------------------------------------------------------------
[35m13:51:03[0m :: # WARNING: avoid using this option if possible. Instead use ACLs to remove
[35m13:51:03[0m :: # commands from the default user, and put them only in some admin user you
[35m13:51:03[0m :: # create for administrative purposes.
[35m13:51:03[0m :: # ------------------------------------------------------------------------
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # It is possible to change the name of dangerous commands in a shared
[35m13:51:03[0m :: # environment. For instance the CONFIG command may be renamed into something
[35m13:51:03[0m :: # hard to guess so that it will still be available for internal-use tools
[35m13:51:03[0m :: # but not available for general clients.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Example:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # It is also possible to completely kill a command by renaming it into
[35m13:51:03[0m :: # an empty string:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # rename-command CONFIG ""
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Please note that changing the name of commands that are logged into the
[35m13:51:03[0m :: # AOF file or transmitted to replicas may cause problems.
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################### CLIENTS ####################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Set the max number of connected clients at the same time. By default
[35m13:51:03[0m :: # this limit is set to 10000 clients, however if the Redis server is not
[35m13:51:03[0m :: # able to configure the process file limit to allow for the specified limit
[35m13:51:03[0m :: # the max number of allowed clients is set to the current file limit
[35m13:51:03[0m :: # minus 32 (as Redis reserves a few file descriptors for internal uses).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Once the limit is reached Redis will close all the new connections sending
[35m13:51:03[0m :: # an error 'max number of clients reached'.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # IMPORTANT: When Redis Cluster is used, the max number of connections is also
[35m13:51:03[0m :: # shared with the cluster bus: every node in the cluster will use two
[35m13:51:03[0m :: # connections, one incoming and another outgoing. It is important to size the
[35m13:51:03[0m :: # limit accordingly in case of very large clusters.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # maxclients 10000
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ############################## MEMORY MANAGEMENT ################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Set a memory usage limit to the specified amount of bytes.
[35m13:51:03[0m :: # When the memory limit is reached Redis will try to remove keys
[35m13:51:03[0m :: # according to the eviction policy selected (see maxmemory-policy).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # If Redis can't remove keys according to the policy, or if the policy is
[35m13:51:03[0m :: # set to 'noeviction', Redis will start to reply with errors to commands
[35m13:51:03[0m :: # that would use more memory, like SET, LPUSH, and so on, and will continue
[35m13:51:03[0m :: # to reply to read-only commands like GET.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # This option is usually useful when using Redis as an LRU or LFU cache, or to
[35m13:51:03[0m :: # set a hard memory limit for an instance (using the 'noeviction' policy).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # WARNING: If you have replicas attached to an instance with maxmemory on,
[35m13:51:03[0m :: # the size of the output buffers needed to feed the replicas are subtracted
[35m13:51:03[0m :: # from the used memory count, so that network problems / resyncs will
[35m13:51:03[0m :: # not trigger a loop where keys are evicted, and in turn the output
[35m13:51:03[0m :: # buffer of replicas is full with DELs of keys evicted triggering the deletion
[35m13:51:03[0m :: # of more keys, and so forth until the database is completely emptied.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # In short... if you have replicas attached it is suggested that you set a lower
[35m13:51:03[0m :: # limit for maxmemory so that there is some free RAM on the system for replica
[35m13:51:03[0m :: # output buffers (but this is not needed if the policy is 'noeviction').
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # maxmemory <bytes>
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
[35m13:51:03[0m :: # is reached. You can select one from the following behaviors:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # volatile-lru -> Evict using approximated LRU, only keys with an expire set.
[35m13:51:03[0m :: # allkeys-lru -> Evict any key using approximated LRU.
[35m13:51:03[0m :: # volatile-lfu -> Evict using approximated LFU, only keys with an expire set.
[35m13:51:03[0m :: # allkeys-lfu -> Evict any key using approximated LFU.
[35m13:51:03[0m :: # volatile-random -> Remove a random key having an expire set.
[35m13:51:03[0m :: # allkeys-random -> Remove a random key, any key.
[35m13:51:03[0m :: # volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
[35m13:51:03[0m :: # noeviction -> Don't evict anything, just return an error on write operations.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # LRU means Least Recently Used
[35m13:51:03[0m :: # LFU means Least Frequently Used
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Both LRU, LFU and volatile-ttl are implemented using approximated
[35m13:51:03[0m :: # randomized algorithms.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note: with any of the above policies, Redis will return an error on write
[35m13:51:03[0m :: #       operations, when there are no suitable keys for eviction.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: #       At the date of writing these commands are: set setnx setex append
[35m13:51:03[0m :: #       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
[35m13:51:03[0m :: #       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
[35m13:51:03[0m :: #       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
[35m13:51:03[0m :: #       getset mset msetnx exec sort
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The default is:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # maxmemory-policy noeviction
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated
[35m13:51:03[0m :: # algorithms (in order to save memory), so you can tune it for speed or
[35m13:51:03[0m :: # accuracy. By default Redis will check five keys and pick the one that was
[35m13:51:03[0m :: # used least recently, you can change the sample size using the following
[35m13:51:03[0m :: # configuration directive.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The default of 5 produces good enough results. 10 Approximates very closely
[35m13:51:03[0m :: # true LRU but costs more CPU. 3 is faster but not very accurate.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # maxmemory-samples 5
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Starting from Redis 5, by default a replica will ignore its maxmemory setting
[35m13:51:03[0m :: # (unless it is promoted to master after a failover or manually). It means
[35m13:51:03[0m :: # that the eviction of keys will be just handled by the master, sending the
[35m13:51:03[0m :: # DEL commands to the replica as keys evict in the master side.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # This behavior ensures that masters and replicas stay consistent, and is usually
[35m13:51:03[0m :: # what you want, however if your replica is writable, or you want the replica
[35m13:51:03[0m :: # to have a different memory setting, and you are sure all the writes performed
[35m13:51:03[0m :: # to the replica are idempotent, then you may change this default (but be sure
[35m13:51:03[0m :: # to understand what you are doing).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Note that since the replica by default does not evict, it may end using more
[35m13:51:03[0m :: # memory than the one set via maxmemory (there are certain buffers that may
[35m13:51:03[0m :: # be larger on the replica, or data structures may sometimes take more memory
[35m13:51:03[0m :: # and so forth). So make sure you monitor your replicas and make sure they
[35m13:51:03[0m :: # have enough memory to never hit a real out-of-memory condition before the
[35m13:51:03[0m :: # master hits the configured maxmemory setting.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # replica-ignore-maxmemory yes
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Redis reclaims expired keys in two ways: upon access when those keys are
[35m13:51:03[0m :: # found to be expired, and also in background, in what is called the
[35m13:51:03[0m :: # "active expire key". The key space is slowly and interactively scanned
[35m13:51:03[0m :: # looking for expired keys to reclaim, so that it is possible to free memory
[35m13:51:03[0m :: # of keys that are expired and will never be accessed again in a short time.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The default effort of the expire cycle will try to avoid having more than
[35m13:51:03[0m :: # ten percent of expired keys still in memory, and will try to avoid consuming
[35m13:51:03[0m :: # more than 25% of total memory and to add latency to the system. However
[35m13:51:03[0m :: # it is possible to increase the expire "effort" that is normally set to
[35m13:51:03[0m :: # "1", to a greater value, up to the value "10". At its maximum value the
[35m13:51:03[0m :: # system will use more CPU, longer cycles (and technically may introduce
[35m13:51:03[0m :: # more latency), and will tolerate less already expired keys still present
[35m13:51:03[0m :: # in the system. It's a tradeoff between memory, CPU and latency.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # active-expire-effort 1
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ############################# LAZY FREEING ####################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Redis has two primitives to delete keys. One is called DEL and is a blocking
[35m13:51:03[0m :: # deletion of the object. It means that the server stops processing new commands
[35m13:51:03[0m :: # in order to reclaim all the memory associated with an object in a synchronous
[35m13:51:03[0m :: # way. If the key deleted is associated with a small object, the time needed
[35m13:51:03[0m :: # in order to execute the DEL command is very small and comparable to most other
[35m13:51:03[0m :: # O(1) or O(log_N) commands in Redis. However if the key is associated with an
[35m13:51:03[0m :: # aggregated value containing millions of elements, the server can block for
[35m13:51:03[0m :: # a long time (even seconds) in order to complete the operation.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # For the above reasons Redis also offers non blocking deletion primitives
[35m13:51:03[0m :: # such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and
[35m13:51:03[0m :: # FLUSHDB commands, in order to reclaim memory in background. Those commands
[35m13:51:03[0m :: # are executed in constant time. Another thread will incrementally free the
[35m13:51:03[0m :: # object in the background as fast as possible.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.
[35m13:51:03[0m :: # It's up to the design of the application to understand when it is a good
[35m13:51:03[0m :: # idea to use one or the other. However the Redis server sometimes has to
[35m13:51:03[0m :: # delete keys or flush the whole database as a side effect of other operations.
[35m13:51:03[0m :: # Specifically Redis deletes objects independently of a user call in the
[35m13:51:03[0m :: # following scenarios:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # 1) On eviction, because of the maxmemory and maxmemory policy configurations,
[35m13:51:03[0m :: #    in order to make room for new data, without going over the specified
[35m13:51:03[0m :: #    memory limit.
[35m13:51:03[0m :: # 2) Because of expire: when a key with an associated time to live (see the
[35m13:51:03[0m :: #    EXPIRE command) must be deleted from memory.
[35m13:51:03[0m :: # 3) Because of a side effect of a command that stores data on a key that may
[35m13:51:03[0m :: #    already exist. For example the RENAME command may delete the old key
[35m13:51:03[0m :: #    content when it is replaced with another one. Similarly SUNIONSTORE
[35m13:51:03[0m :: #    or SORT with STORE option may delete existing keys. The SET command
[35m13:51:03[0m :: #    itself removes any old content of the specified key in order to replace
[35m13:51:03[0m :: #    it with the specified string.
[35m13:51:03[0m :: # 4) During replication, when a replica performs a full resynchronization with
[35m13:51:03[0m :: #    its master, the content of the whole database is removed in order to
[35m13:51:03[0m :: #    load the RDB file just transferred.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # In all the above cases the default is to delete objects in a blocking way,
[35m13:51:03[0m :: # like if DEL was called. However you can configure each case specifically
[35m13:51:03[0m :: # in order to instead release memory in a non-blocking way like if UNLINK
[35m13:51:03[0m :: # was called, using the following configuration directives.
[35m13:51:03[0m :: 
[35m13:51:03[0m :: lazyfree-lazy-eviction no
[35m13:51:03[0m :: lazyfree-lazy-expire no
[35m13:51:03[0m :: lazyfree-lazy-server-del no
[35m13:51:03[0m :: replica-lazy-flush no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # It is also possible, for the case when to replace the user code DEL calls
[35m13:51:03[0m :: # with UNLINK calls is not easy, to modify the default behavior of the DEL
[35m13:51:03[0m :: # command to act exactly like UNLINK, using the following configuration
[35m13:51:03[0m :: # directive:
[35m13:51:03[0m :: 
[35m13:51:03[0m :: lazyfree-lazy-user-del no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ################################ THREADED I/O #################################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # Redis is mostly single threaded, however there are certain threaded
[35m13:51:03[0m :: # operations such as UNLINK, slow I/O accesses and other things that are
[35m13:51:03[0m :: # performed on side threads.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Now it is also possible to handle Redis clients socket reads and writes
[35m13:51:03[0m :: # in different I/O threads. Since especially writing is so slow, normally
[35m13:51:03[0m :: # Redis users use pipelining in order to speed up the Redis performances per
[35m13:51:03[0m :: # core, and spawn multiple instances in order to scale more. Using I/O
[35m13:51:03[0m :: # threads it is possible to easily speedup two times Redis without resorting
[35m13:51:03[0m :: # to pipelining nor sharding of the instance.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # By default threading is disabled, we suggest enabling it only in machines
[35m13:51:03[0m :: # that have at least 4 or more cores, leaving at least one spare core.
[35m13:51:03[0m :: # Using more than 8 threads is unlikely to help much. We also recommend using
[35m13:51:03[0m :: # threaded I/O only if you actually have performance problems, with Redis
[35m13:51:03[0m :: # instances being able to use a quite big percentage of CPU time, otherwise
[35m13:51:03[0m :: # there is no point in using this feature.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # So for instance if you have a four cores boxes, try to use 2 or 3 I/O
[35m13:51:03[0m :: # threads, if you have a 8 cores, try to use 6 threads. In order to
[35m13:51:03[0m :: # enable I/O threads use the following configuration directive:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # io-threads 4
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Setting io-threads to 1 will just use the main thread as usual.
[35m13:51:03[0m :: # When I/O threads are enabled, we only use threads for writes, that is
[35m13:51:03[0m :: # to thread the write(2) syscall and transfer the client buffers to the
[35m13:51:03[0m :: # socket. However it is also possible to enable threading of reads and
[35m13:51:03[0m :: # protocol parsing using the following configuration directive, by setting
[35m13:51:03[0m :: # it to yes:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # io-threads-do-reads no
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Usually threading reads doesn't help much.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # NOTE 1: This configuration directive cannot be changed at runtime via
[35m13:51:03[0m :: # CONFIG SET. Aso this feature currently does not work when SSL is
[35m13:51:03[0m :: # enabled.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # NOTE 2: If you want to test the Redis speedup using redis-benchmark, make
[35m13:51:03[0m :: # sure you also run the benchmark itself in threaded mode, using the
[35m13:51:03[0m :: # --threads option to match the number of Redis threads, otherwise you'll not
[35m13:51:03[0m :: # be able to notice the improvements.
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ############################ KERNEL OOM CONTROL ##############################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # On Linux, it is possible to hint the kernel OOM killer on what processes
[35m13:51:03[0m :: # should be killed first when out of memory.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Enabling this feature makes Redis actively control the oom_score_adj value
[35m13:51:03[0m :: # for all its processes, depending on their role. The default scores will
[35m13:51:03[0m :: # attempt to have background child processes killed before all others, and
[35m13:51:03[0m :: # replicas killed before masters.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Redis supports three options:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # no:       Don't make changes to oom-score-adj (default).
[35m13:51:03[0m :: # yes:      Alias to "relative" see below.
[35m13:51:03[0m :: # absolute: Values in oom-score-adj-values are written as is to the kernel.
[35m13:51:03[0m :: # relative: Values are used relative to the initial value of oom_score_adj when
[35m13:51:03[0m :: #           the server starts and are then clamped to a range of -1000 to 1000.
[35m13:51:03[0m :: #           Because typically the initial value is 0, they will often match the
[35m13:51:03[0m :: #           absolute values.
[35m13:51:03[0m :: oom-score-adj no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # When oom-score-adj is used, this directive controls the specific values used
[35m13:51:03[0m :: # for master, replica and background child processes. Values range -2000 to
[35m13:51:03[0m :: # 2000 (higher means more likely to be killed).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Unprivileged processes (not root, and without CAP_SYS_RESOURCE capabilities)
[35m13:51:03[0m :: # can freely increase their value, but not decrease it below its initial
[35m13:51:03[0m :: # settings. This means that setting oom-score-adj to "relative" and setting the
[35m13:51:03[0m :: # oom-score-adj-values to positive values will always succeed.
[35m13:51:03[0m :: oom-score-adj-values 0 200 800
[35m13:51:03[0m :: 
[35m13:51:03[0m :: ############################## APPEND ONLY MODE ###############################
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # By default Redis asynchronously dumps the dataset on disk. This mode is
[35m13:51:03[0m :: # good enough in many applications, but an issue with the Redis process or
[35m13:51:03[0m :: # a power outage may result into a few minutes of writes lost (depending on
[35m13:51:03[0m :: # the configured save points).
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The Append Only File is an alternative persistence mode that provides
[35m13:51:03[0m :: # much better durability. For instance using the default data fsync policy
[35m13:51:03[0m :: # (see later in the config file) Redis can lose just one second of writes in a
[35m13:51:03[0m :: # dramatic event like a server power outage, or a single write if something
[35m13:51:03[0m :: # wrong with the Redis process itself happens, but the operating system is
[35m13:51:03[0m :: # still running correctly.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # AOF and RDB persistence can be enabled at the same time without problems.
[35m13:51:03[0m :: # If the AOF is enabled on startup Redis will load the AOF, that is the file
[35m13:51:03[0m :: # with the better durability guarantees.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Please check http://redis.io/topics/persistence for more information.
[35m13:51:03[0m :: 
[35m13:51:03[0m :: appendonly no
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # The name of the append only file (default: "appendonly.aof")
[35m13:51:03[0m :: 
[35m13:51:03[0m :: appendfilename "appendonly.aof"
[35m13:51:03[0m :: 
[35m13:51:03[0m :: # The fsync() call tells the Operating System to actually write data on disk
[35m13:51:03[0m :: # instead of waiting for more data in the output buffer. Some OS will really flush
[35m13:51:03[0m :: # data on disk, some other OS will just try to do it ASAP.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # Redis supports three different modes:
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # no: don't fsync, just let the OS flush the data when it wants. Faster.
[35m13:51:03[0m :: # always: fsync after every write to the append only log. Slow, Safest.
[35m13:51:03[0m :: # everysec: fsync only one time every second. Compromise.
[35m13:51:03[0m :: #
[35m13:51:03[0m :: # The default is "everysec", as that's usually the right compromise between
[35m13:51:03[0m :: # speed and data safety. It's up to you to understand if you can relax this to
[35m13:51:03[0m :: # "no" that will let the operating system flush the output buffer when
[35m13:51:03[0m :: # it wants, for better performances (but if you can live with the idea of
[35m13:51:03[0m :: # some data loss consider the default persistence mode that's snapshotting),
[35m13:51:03[0m :: # or on the contrary, use "always" that's very slow but a bit safer than
[35m13:51:03[0m :: # everysec.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # More details please check the following article:
[35m13:51:04[0m :: # http://antirez.com/post/redis-persistence-demystified.html
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # If unsure, use "everysec".
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # appendfsync always
[35m13:51:04[0m :: appendfsync everysec
[35m13:51:04[0m :: # appendfsync no
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # When the AOF fsync policy is set to always or everysec, and a background
[35m13:51:04[0m :: # saving process (a background save or AOF log background rewriting) is
[35m13:51:04[0m :: # performing a lot of I/O against the disk, in some Linux configurations
[35m13:51:04[0m :: # Redis may block too long on the fsync() call. Note that there is no fix for
[35m13:51:04[0m :: # this currently, as even performing fsync in a different thread will block
[35m13:51:04[0m :: # our synchronous write(2) call.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # In order to mitigate this problem it's possible to use the following option
[35m13:51:04[0m :: # that will prevent fsync() from being called in the main process while a
[35m13:51:04[0m :: # BGSAVE or BGREWRITEAOF is in progress.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # This means that while another child is saving, the durability of Redis is
[35m13:51:04[0m :: # the same as "appendfsync none". In practical terms, this means that it is
[35m13:51:04[0m :: # possible to lose up to 30 seconds of log in the worst scenario (with the
[35m13:51:04[0m :: # default Linux settings).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # If you have latency problems turn this to "yes". Otherwise leave it as
[35m13:51:04[0m :: # "no" that is the safest pick from the point of view of durability.
[35m13:51:04[0m :: 
[35m13:51:04[0m :: no-appendfsync-on-rewrite no
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Automatic rewrite of the append only file.
[35m13:51:04[0m :: # Redis is able to automatically rewrite the log file implicitly calling
[35m13:51:04[0m :: # BGREWRITEAOF when the AOF log size grows by the specified percentage.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # This is how it works: Redis remembers the size of the AOF file after the
[35m13:51:04[0m :: # latest rewrite (if no rewrite has happened since the restart, the size of
[35m13:51:04[0m :: # the AOF at startup is used).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # This base size is compared to the current size. If the current size is
[35m13:51:04[0m :: # bigger than the specified percentage, the rewrite is triggered. Also
[35m13:51:04[0m :: # you need to specify a minimal size for the AOF file to be rewritten, this
[35m13:51:04[0m :: # is useful to avoid rewriting the AOF file even if the percentage increase
[35m13:51:04[0m :: # is reached but it is still pretty small.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Specify a percentage of zero in order to disable the automatic AOF
[35m13:51:04[0m :: # rewrite feature.
[35m13:51:04[0m :: 
[35m13:51:04[0m :: auto-aof-rewrite-percentage 100
[35m13:51:04[0m :: auto-aof-rewrite-min-size 64mb
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # An AOF file may be found to be truncated at the end during the Redis
[35m13:51:04[0m :: # startup process, when the AOF data gets loaded back into memory.
[35m13:51:04[0m :: # This may happen when the system where Redis is running
[35m13:51:04[0m :: # crashes, especially when an ext4 filesystem is mounted without the
[35m13:51:04[0m :: # data=ordered option (however this can't happen when Redis itself
[35m13:51:04[0m :: # crashes or aborts but the operating system still works correctly).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Redis can either exit with an error when this happens, or load as much
[35m13:51:04[0m :: # data as possible (the default now) and start if the AOF file is found
[35m13:51:04[0m :: # to be truncated at the end. The following option controls this behavior.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # If aof-load-truncated is set to yes, a truncated AOF file is loaded and
[35m13:51:04[0m :: # the Redis server starts emitting a log to inform the user of the event.
[35m13:51:04[0m :: # Otherwise if the option is set to no, the server aborts with an error
[35m13:51:04[0m :: # and refuses to start. When the option is set to no, the user requires
[35m13:51:04[0m :: # to fix the AOF file using the "redis-check-aof" utility before to restart
[35m13:51:04[0m :: # the server.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Note that if the AOF file will be found to be corrupted in the middle
[35m13:51:04[0m :: # the server will still exit with an error. This option only applies when
[35m13:51:04[0m :: # Redis will try to read more data from the AOF file but not enough bytes
[35m13:51:04[0m :: # will be found.
[35m13:51:04[0m :: aof-load-truncated yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # When rewriting the AOF file, Redis is able to use an RDB preamble in the
[35m13:51:04[0m :: # AOF file for faster rewrites and recoveries. When this option is turned
[35m13:51:04[0m :: # on the rewritten AOF file is composed of two different stanzas:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #   [RDB file][AOF tail]
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # When loading, Redis recognizes that the AOF file starts with the "REDIS"
[35m13:51:04[0m :: # string and loads the prefixed RDB file, then continues loading the AOF
[35m13:51:04[0m :: # tail.
[35m13:51:04[0m :: aof-use-rdb-preamble yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ################################ LUA SCRIPTING  ###############################
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Max execution time of a Lua script in milliseconds.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # If the maximum execution time is reached Redis will log that a script is
[35m13:51:04[0m :: # still in execution after the maximum allowed time and will start to
[35m13:51:04[0m :: # reply to queries with an error.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # When a long running script exceeds the maximum execution time only the
[35m13:51:04[0m :: # SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be
[35m13:51:04[0m :: # used to stop a script that did not yet call any write commands. The second
[35m13:51:04[0m :: # is the only way to shut down the server in the case a write command was
[35m13:51:04[0m :: # already issued by the script but the user doesn't want to wait for the natural
[35m13:51:04[0m :: # termination of the script.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Set it to 0 or a negative value for unlimited execution without warnings.
[35m13:51:04[0m :: lua-time-limit 5000
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ################################ REDIS CLUSTER  ###############################
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Normal Redis instances can't be part of a Redis Cluster; only nodes that are
[35m13:51:04[0m :: # started as cluster nodes can. In order to start a Redis instance as a
[35m13:51:04[0m :: # cluster node enable the cluster support uncommenting the following:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-enabled yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Every cluster node has a cluster configuration file. This file is not
[35m13:51:04[0m :: # intended to be edited by hand. It is created and updated by Redis nodes.
[35m13:51:04[0m :: # Every Redis Cluster node requires a different cluster configuration file.
[35m13:51:04[0m :: # Make sure that instances running in the same system do not have
[35m13:51:04[0m :: # overlapping cluster configuration file names.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-config-file nodes-6379.conf
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Cluster node timeout is the amount of milliseconds a node must be unreachable
[35m13:51:04[0m :: # for it to be considered in failure state.
[35m13:51:04[0m :: # Most other internal time limits are a multiple of the node timeout.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-node-timeout 15000
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # A replica of a failing master will avoid to start a failover if its data
[35m13:51:04[0m :: # looks too old.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # There is no simple way for a replica to actually have an exact measure of
[35m13:51:04[0m :: # its "data age", so the following two checks are performed:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # 1) If there are multiple replicas able to failover, they exchange messages
[35m13:51:04[0m :: #    in order to try to give an advantage to the replica with the best
[35m13:51:04[0m :: #    replication offset (more data from the master processed).
[35m13:51:04[0m :: #    Replicas will try to get their rank by offset, and apply to the start
[35m13:51:04[0m :: #    of the failover a delay proportional to their rank.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # 2) Every single replica computes the time of the last interaction with
[35m13:51:04[0m :: #    its master. This can be the last ping or command received (if the master
[35m13:51:04[0m :: #    is still in the "connected" state), or the time that elapsed since the
[35m13:51:04[0m :: #    disconnection with the master (if the replication link is currently down).
[35m13:51:04[0m :: #    If the last interaction is too old, the replica will not try to failover
[35m13:51:04[0m :: #    at all.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The point "2" can be tuned by user. Specifically a replica will not perform
[35m13:51:04[0m :: # the failover if, since the last interaction with the master, the time
[35m13:51:04[0m :: # elapsed is greater than:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #   (node-timeout * cluster-replica-validity-factor) + repl-ping-replica-period
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # So for example if node-timeout is 30 seconds, and the cluster-replica-validity-factor
[35m13:51:04[0m :: # is 10, and assuming a default repl-ping-replica-period of 10 seconds, the
[35m13:51:04[0m :: # replica will not try to failover if it was not able to talk with the master
[35m13:51:04[0m :: # for longer than 310 seconds.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # A large cluster-replica-validity-factor may allow replicas with too old data to failover
[35m13:51:04[0m :: # a master, while a too small value may prevent the cluster from being able to
[35m13:51:04[0m :: # elect a replica at all.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # For maximum availability, it is possible to set the cluster-replica-validity-factor
[35m13:51:04[0m :: # to a value of 0, which means, that replicas will always try to failover the
[35m13:51:04[0m :: # master regardless of the last time they interacted with the master.
[35m13:51:04[0m :: # (However they'll always try to apply a delay proportional to their
[35m13:51:04[0m :: # offset rank).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Zero is the only value able to guarantee that when all the partitions heal
[35m13:51:04[0m :: # the cluster will always be able to continue.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-replica-validity-factor 10
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Cluster replicas are able to migrate to orphaned masters, that are masters
[35m13:51:04[0m :: # that are left without working replicas. This improves the cluster ability
[35m13:51:04[0m :: # to resist to failures as otherwise an orphaned master can't be failed over
[35m13:51:04[0m :: # in case of failure if it has no working replicas.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Replicas migrate to orphaned masters only if there are still at least a
[35m13:51:04[0m :: # given number of other working replicas for their old master. This number
[35m13:51:04[0m :: # is the "migration barrier". A migration barrier of 1 means that a replica
[35m13:51:04[0m :: # will migrate only if there is at least 1 other working replica for its master
[35m13:51:04[0m :: # and so forth. It usually reflects the number of replicas you want for every
[35m13:51:04[0m :: # master in your cluster.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Default is 1 (replicas migrate only if their masters remain with at least
[35m13:51:04[0m :: # one replica). To disable migration just set it to a very large value.
[35m13:51:04[0m :: # A value of 0 can be set but is useful only for debugging and dangerous
[35m13:51:04[0m :: # in production.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-migration-barrier 1
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # By default Redis Cluster nodes stop accepting queries if they detect there
[35m13:51:04[0m :: # is at least a hash slot uncovered (no available node is serving it).
[35m13:51:04[0m :: # This way if the cluster is partially down (for example a range of hash slots
[35m13:51:04[0m :: # are no longer covered) all the cluster becomes, eventually, unavailable.
[35m13:51:04[0m :: # It automatically returns available as soon as all the slots are covered again.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # However sometimes you want the subset of the cluster which is working,
[35m13:51:04[0m :: # to continue to accept queries for the part of the key space that is still
[35m13:51:04[0m :: # covered. In order to do so, just set the cluster-require-full-coverage
[35m13:51:04[0m :: # option to no.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-require-full-coverage yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # This option, when set to yes, prevents replicas from trying to failover its
[35m13:51:04[0m :: # master during master failures. However the master can still perform a
[35m13:51:04[0m :: # manual failover, if forced to do so.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # This is useful in different scenarios, especially in the case of multiple
[35m13:51:04[0m :: # data center operations, where we want one side to never be promoted if not
[35m13:51:04[0m :: # in the case of a total DC failure.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-replica-no-failover no
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # This option, when set to yes, allows nodes to serve read traffic while the
[35m13:51:04[0m :: # the cluster is in a down state, as long as it believes it owns the slots. 
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # This is useful for two cases.  The first case is for when an application 
[35m13:51:04[0m :: # doesn't require consistency of data during node failures or network partitions.
[35m13:51:04[0m :: # One example of this is a cache, where as long as the node has the data it
[35m13:51:04[0m :: # should be able to serve it. 
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The second use case is for configurations that don't meet the recommended  
[35m13:51:04[0m :: # three shards but want to enable cluster mode and scale later. A 
[35m13:51:04[0m :: # master outage in a 1 or 2 shard configuration causes a read/write outage to the
[35m13:51:04[0m :: # entire cluster without this option set, with it set there is only a write outage.
[35m13:51:04[0m :: # Without a quorum of masters, slot ownership will not change automatically. 
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-allow-reads-when-down no
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # In order to setup your cluster make sure to read the documentation
[35m13:51:04[0m :: # available at http://redis.io web site.
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ########################## CLUSTER DOCKER/NAT support  ########################
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # In certain deployments, Redis Cluster nodes address discovery fails, because
[35m13:51:04[0m :: # addresses are NAT-ted or because ports are forwarded (the typical case is
[35m13:51:04[0m :: # Docker and other containers).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # In order to make Redis Cluster working in such environments, a static
[35m13:51:04[0m :: # configuration where each node knows its public address is needed. The
[35m13:51:04[0m :: # following two options are used for this scope, and are:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # * cluster-announce-ip
[35m13:51:04[0m :: # * cluster-announce-port
[35m13:51:04[0m :: # * cluster-announce-bus-port
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Each instructs the node about its address, client port, and cluster message
[35m13:51:04[0m :: # bus port. The information is then published in the header of the bus packets
[35m13:51:04[0m :: # so that other nodes will be able to correctly map the address of the node
[35m13:51:04[0m :: # publishing the information.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # If the above options are not used, the normal Redis Cluster auto-detection
[35m13:51:04[0m :: # will be used instead.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Note that when remapped, the bus port may not be at the fixed offset of
[35m13:51:04[0m :: # clients port + 10000, so you can specify any port and bus-port depending
[35m13:51:04[0m :: # on how they get remapped. If the bus-port is not set, a fixed offset of
[35m13:51:04[0m :: # 10000 will be used as usual.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Example:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # cluster-announce-ip 10.1.1.5
[35m13:51:04[0m :: # cluster-announce-port 6379
[35m13:51:04[0m :: # cluster-announce-bus-port 6380
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ################################## SLOW LOG ###################################
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # The Redis Slow Log is a system to log queries that exceeded a specified
[35m13:51:04[0m :: # execution time. The execution time does not include the I/O operations
[35m13:51:04[0m :: # like talking with the client, sending the reply and so forth,
[35m13:51:04[0m :: # but just the time needed to actually execute the command (this is the only
[35m13:51:04[0m :: # stage of command execution where the thread is blocked and can not serve
[35m13:51:04[0m :: # other requests in the meantime).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # You can configure the slow log with two parameters: one tells Redis
[35m13:51:04[0m :: # what is the execution time, in microseconds, to exceed in order for the
[35m13:51:04[0m :: # command to get logged, and the other parameter is the length of the
[35m13:51:04[0m :: # slow log. When a new command is logged the oldest one is removed from the
[35m13:51:04[0m :: # queue of logged commands.
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # The following time is expressed in microseconds, so 1000000 is equivalent
[35m13:51:04[0m :: # to one second. Note that a negative number disables the slow log, while
[35m13:51:04[0m :: # a value of zero forces the logging of every command.
[35m13:51:04[0m :: slowlog-log-slower-than 10000
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # There is no limit to this length. Just be aware that it will consume memory.
[35m13:51:04[0m :: # You can reclaim memory used by the slow log with SLOWLOG RESET.
[35m13:51:04[0m :: slowlog-max-len 128
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ################################ LATENCY MONITOR ##############################
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # The Redis latency monitoring subsystem samples different operations
[35m13:51:04[0m :: # at runtime in order to collect data related to possible sources of
[35m13:51:04[0m :: # latency of a Redis instance.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Via the LATENCY command this information is available to the user that can
[35m13:51:04[0m :: # print graphs and obtain reports.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The system only logs operations that were performed in a time equal or
[35m13:51:04[0m :: # greater than the amount of milliseconds specified via the
[35m13:51:04[0m :: # latency-monitor-threshold configuration directive. When its value is set
[35m13:51:04[0m :: # to zero, the latency monitor is turned off.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # By default latency monitoring is disabled since it is mostly not needed
[35m13:51:04[0m :: # if you don't have latency issues, and collecting data has a performance
[35m13:51:04[0m :: # impact, that while very small, can be measured under big load. Latency
[35m13:51:04[0m :: # monitoring can easily be enabled at runtime using the command
[35m13:51:04[0m :: # "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.
[35m13:51:04[0m :: latency-monitor-threshold 0
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ############################# EVENT NOTIFICATION ##############################
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Redis can notify Pub/Sub clients about events happening in the key space.
[35m13:51:04[0m :: # This feature is documented at http://redis.io/topics/notifications
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # For instance if keyspace events notification is enabled, and a client
[35m13:51:04[0m :: # performs a DEL operation on key "foo" stored in the Database 0, two
[35m13:51:04[0m :: # messages will be published via Pub/Sub:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # PUBLISH __keyspace@0__:foo del
[35m13:51:04[0m :: # PUBLISH __keyevent@0__:del foo
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # It is possible to select the events that Redis will notify among a set
[35m13:51:04[0m :: # of classes. Every class is identified by a single character:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #  K     Keyspace events, published with __keyspace@<db>__ prefix.
[35m13:51:04[0m :: #  E     Keyevent events, published with __keyevent@<db>__ prefix.
[35m13:51:04[0m :: #  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
[35m13:51:04[0m :: #  $     String commands
[35m13:51:04[0m :: #  l     List commands
[35m13:51:04[0m :: #  s     Set commands
[35m13:51:04[0m :: #  h     Hash commands
[35m13:51:04[0m :: #  z     Sorted set commands
[35m13:51:04[0m :: #  x     Expired events (events generated every time a key expires)
[35m13:51:04[0m :: #  e     Evicted events (events generated when a key is evicted for maxmemory)
[35m13:51:04[0m :: #  t     Stream commands
[35m13:51:04[0m :: #  m     Key-miss events (Note: It is not included in the 'A' class)
[35m13:51:04[0m :: #  A     Alias for g$lshzxet, so that the "AKE" string means all the events
[35m13:51:04[0m :: #        (Except key-miss events which are excluded from 'A' due to their
[35m13:51:04[0m :: #         unique nature).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #  The "notify-keyspace-events" takes as argument a string that is composed
[35m13:51:04[0m :: #  of zero or multiple characters. The empty string means that notifications
[35m13:51:04[0m :: #  are disabled.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #  Example: to enable list and generic events, from the point of view of the
[35m13:51:04[0m :: #           event name, use:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #  notify-keyspace-events Elg
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #  Example 2: to get the stream of the expired keys subscribing to channel
[35m13:51:04[0m :: #             name __keyevent@0__:expired use:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #  notify-keyspace-events Ex
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #  By default all notifications are disabled because most users don't need
[35m13:51:04[0m :: #  this feature and the feature has some overhead. Note that if you don't
[35m13:51:04[0m :: #  specify at least one of K or E, no events will be delivered.
[35m13:51:04[0m :: notify-keyspace-events ""
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ############################### GOPHER SERVER #################################
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Redis contains an implementation of the Gopher protocol, as specified in
[35m13:51:04[0m :: # the RFC 1436 (https://www.ietf.org/rfc/rfc1436.txt).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The Gopher protocol was very popular in the late '90s. It is an alternative
[35m13:51:04[0m :: # to the web, and the implementation both server and client side is so simple
[35m13:51:04[0m :: # that the Redis server has just 100 lines of code in order to implement this
[35m13:51:04[0m :: # support.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # What do you do with Gopher nowadays? Well Gopher never *really* died, and
[35m13:51:04[0m :: # lately there is a movement in order for the Gopher more hierarchical content
[35m13:51:04[0m :: # composed of just plain text documents to be resurrected. Some want a simpler
[35m13:51:04[0m :: # internet, others believe that the mainstream internet became too much
[35m13:51:04[0m :: # controlled, and it's cool to create an alternative space for people that
[35m13:51:04[0m :: # want a bit of fresh air.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Anyway for the 10nth birthday of the Redis, we gave it the Gopher protocol
[35m13:51:04[0m :: # as a gift.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # --- HOW IT WORKS? ---
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The Redis Gopher support uses the inline protocol of Redis, and specifically
[35m13:51:04[0m :: # two kind of inline requests that were anyway illegal: an empty request
[35m13:51:04[0m :: # or any request that starts with "/" (there are no Redis commands starting
[35m13:51:04[0m :: # with such a slash). Normal RESP2/RESP3 requests are completely out of the
[35m13:51:04[0m :: # path of the Gopher protocol implementation and are served as usual as well.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # If you open a connection to Redis when Gopher is enabled and send it
[35m13:51:04[0m :: # a string like "/foo", if there is a key named "/foo" it is served via the
[35m13:51:04[0m :: # Gopher protocol.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # In order to create a real Gopher "hole" (the name of a Gopher site in Gopher
[35m13:51:04[0m :: # talking), you likely need a script like the following:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #   https://github.com/antirez/gopher2redis
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # --- SECURITY WARNING ---
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # If you plan to put Redis on the internet in a publicly accessible address
[35m13:51:04[0m :: # to server Gopher pages MAKE SURE TO SET A PASSWORD to the instance.
[35m13:51:04[0m :: # Once a password is set:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #   1. The Gopher server (when enabled, not by default) will still serve
[35m13:51:04[0m :: #      content via Gopher.
[35m13:51:04[0m :: #   2. However other commands cannot be called before the client will
[35m13:51:04[0m :: #      authenticate.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # So use the 'requirepass' option to protect your instance.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Note that Gopher is not currently supported when 'io-threads-do-reads'
[35m13:51:04[0m :: # is enabled.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # To enable Gopher support, uncomment the following line and set the option
[35m13:51:04[0m :: # from no (the default) to yes.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # gopher-enabled no
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ############################### ADVANCED CONFIG ###############################
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Hashes are encoded using a memory efficient data structure when they have a
[35m13:51:04[0m :: # small number of entries, and the biggest entry does not exceed a given
[35m13:51:04[0m :: # threshold. These thresholds can be configured using the following directives.
[35m13:51:04[0m :: hash-max-ziplist-entries 512
[35m13:51:04[0m :: hash-max-ziplist-value 64
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Lists are also encoded in a special way to save a lot of space.
[35m13:51:04[0m :: # The number of entries allowed per internal list node can be specified
[35m13:51:04[0m :: # as a fixed maximum size or a maximum number of elements.
[35m13:51:04[0m :: # For a fixed maximum size, use -5 through -1, meaning:
[35m13:51:04[0m :: # -5: max size: 64 Kb  <-- not recommended for normal workloads
[35m13:51:04[0m :: # -4: max size: 32 Kb  <-- not recommended
[35m13:51:04[0m :: # -3: max size: 16 Kb  <-- probably not recommended
[35m13:51:04[0m :: # -2: max size: 8 Kb   <-- good
[35m13:51:04[0m :: # -1: max size: 4 Kb   <-- good
[35m13:51:04[0m :: # Positive numbers mean store up to _exactly_ that number of elements
[35m13:51:04[0m :: # per list node.
[35m13:51:04[0m :: # The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),
[35m13:51:04[0m :: # but if your use case is unique, adjust the settings as necessary.
[35m13:51:04[0m :: list-max-ziplist-size -2
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Lists may also be compressed.
[35m13:51:04[0m :: # Compress depth is the number of quicklist ziplist nodes from *each* side of
[35m13:51:04[0m :: # the list to *exclude* from compression.  The head and tail of the list
[35m13:51:04[0m :: # are always uncompressed for fast push/pop operations.  Settings are:
[35m13:51:04[0m :: # 0: disable all list compression
[35m13:51:04[0m :: # 1: depth 1 means "don't start compressing until after 1 node into the list,
[35m13:51:04[0m :: #    going from either the head or tail"
[35m13:51:04[0m :: #    So: [head]->node->node->...->node->[tail]
[35m13:51:04[0m :: #    [head], [tail] will always be uncompressed; inner nodes will compress.
[35m13:51:04[0m :: # 2: [head]->[next]->node->node->...->node->[prev]->[tail]
[35m13:51:04[0m :: #    2 here means: don't compress head or head->next or tail->prev or tail,
[35m13:51:04[0m :: #    but compress all nodes between them.
[35m13:51:04[0m :: # 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]
[35m13:51:04[0m :: # etc.
[35m13:51:04[0m :: list-compress-depth 0
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Sets have a special encoding in just one case: when a set is composed
[35m13:51:04[0m :: # of just strings that happen to be integers in radix 10 in the range
[35m13:51:04[0m :: # of 64 bit signed integers.
[35m13:51:04[0m :: # The following configuration setting sets the limit in the size of the
[35m13:51:04[0m :: # set in order to use this special memory saving encoding.
[35m13:51:04[0m :: set-max-intset-entries 512
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Similarly to hashes and lists, sorted sets are also specially encoded in
[35m13:51:04[0m :: # order to save a lot of space. This encoding is only used when the length and
[35m13:51:04[0m :: # elements of a sorted set are below the following limits:
[35m13:51:04[0m :: zset-max-ziplist-entries 128
[35m13:51:04[0m :: zset-max-ziplist-value 64
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # HyperLogLog sparse representation bytes limit. The limit includes the
[35m13:51:04[0m :: # 16 bytes header. When an HyperLogLog using the sparse representation crosses
[35m13:51:04[0m :: # this limit, it is converted into the dense representation.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # A value greater than 16000 is totally useless, since at that point the
[35m13:51:04[0m :: # dense representation is more memory efficient.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The suggested value is ~ 3000 in order to have the benefits of
[35m13:51:04[0m :: # the space efficient encoding without slowing down too much PFADD,
[35m13:51:04[0m :: # which is O(N) with the sparse encoding. The value can be raised to
[35m13:51:04[0m :: # ~ 10000 when CPU is not a concern, but space is, and the data set is
[35m13:51:04[0m :: # composed of many HyperLogLogs with cardinality in the 0 - 15000 range.
[35m13:51:04[0m :: hll-sparse-max-bytes 3000
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Streams macro node max size / items. The stream data structure is a radix
[35m13:51:04[0m :: # tree of big nodes that encode multiple items inside. Using this configuration
[35m13:51:04[0m :: # it is possible to configure how big a single node can be in bytes, and the
[35m13:51:04[0m :: # maximum number of items it may contain before switching to a new node when
[35m13:51:04[0m :: # appending new stream entries. If any of the following settings are set to
[35m13:51:04[0m :: # zero, the limit is ignored, so for instance it is possible to set just a
[35m13:51:04[0m :: # max entires limit by setting max-bytes to 0 and max-entries to the desired
[35m13:51:04[0m :: # value.
[35m13:51:04[0m :: stream-node-max-bytes 4096
[35m13:51:04[0m :: stream-node-max-entries 100
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
[35m13:51:04[0m :: # order to help rehashing the main Redis hash table (the one mapping top-level
[35m13:51:04[0m :: # keys to values). The hash table implementation Redis uses (see dict.c)
[35m13:51:04[0m :: # performs a lazy rehashing: the more operation you run into a hash table
[35m13:51:04[0m :: # that is rehashing, the more rehashing "steps" are performed, so if the
[35m13:51:04[0m :: # server is idle the rehashing is never complete and some more memory is used
[35m13:51:04[0m :: # by the hash table.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The default is to use this millisecond 10 times every second in order to
[35m13:51:04[0m :: # actively rehash the main dictionaries, freeing memory when possible.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # If unsure:
[35m13:51:04[0m :: # use "activerehashing no" if you have hard latency requirements and it is
[35m13:51:04[0m :: # not a good thing in your environment that Redis can reply from time to time
[35m13:51:04[0m :: # to queries with 2 milliseconds delay.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # use "activerehashing yes" if you don't have such hard requirements but
[35m13:51:04[0m :: # want to free memory asap when possible.
[35m13:51:04[0m :: activerehashing yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # The client output buffer limits can be used to force disconnection of clients
[35m13:51:04[0m :: # that are not reading data from the server fast enough for some reason (a
[35m13:51:04[0m :: # common reason is that a Pub/Sub client can't consume messages as fast as the
[35m13:51:04[0m :: # publisher can produce them).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The limit can be set differently for the three different classes of clients:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # normal -> normal clients including MONITOR clients
[35m13:51:04[0m :: # replica  -> replica clients
[35m13:51:04[0m :: # pubsub -> clients subscribed to at least one pubsub channel or pattern
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The syntax of every client-output-buffer-limit directive is the following:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # A client is immediately disconnected once the hard limit is reached, or if
[35m13:51:04[0m :: # the soft limit is reached and remains reached for the specified number of
[35m13:51:04[0m :: # seconds (continuously).
[35m13:51:04[0m :: # So for instance if the hard limit is 32 megabytes and the soft limit is
[35m13:51:04[0m :: # 16 megabytes / 10 seconds, the client will get disconnected immediately
[35m13:51:04[0m :: # if the size of the output buffers reach 32 megabytes, but will also get
[35m13:51:04[0m :: # disconnected if the client reaches 16 megabytes and continuously overcomes
[35m13:51:04[0m :: # the limit for 10 seconds.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # By default normal clients are not limited because they don't receive data
[35m13:51:04[0m :: # without asking (in a push way), but just after a request, so only
[35m13:51:04[0m :: # asynchronous clients may create a scenario where data is requested faster
[35m13:51:04[0m :: # than it can read.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Instead there is a default limit for pubsub and replica clients, since
[35m13:51:04[0m :: # subscribers and replicas receive data in a push fashion.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Both the hard or the soft limit can be disabled by setting them to zero.
[35m13:51:04[0m :: client-output-buffer-limit normal 0 0 0
[35m13:51:04[0m :: client-output-buffer-limit replica 256mb 64mb 60
[35m13:51:04[0m :: client-output-buffer-limit pubsub 32mb 8mb 60
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Client query buffers accumulate new commands. They are limited to a fixed
[35m13:51:04[0m :: # amount by default in order to avoid that a protocol desynchronization (for
[35m13:51:04[0m :: # instance due to a bug in the client) will lead to unbound memory usage in
[35m13:51:04[0m :: # the query buffer. However you can configure it here if you have very special
[35m13:51:04[0m :: # needs, such us huge multi/exec requests or alike.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # client-query-buffer-limit 1gb
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # In the Redis protocol, bulk requests, that are, elements representing single
[35m13:51:04[0m :: # strings, are normally limited to 512 mb. However you can change this limit
[35m13:51:04[0m :: # here, but must be 1mb or greater
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # proto-max-bulk-len 512mb
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Redis calls an internal function to perform many background tasks, like
[35m13:51:04[0m :: # closing connections of clients in timeout, purging expired keys that are
[35m13:51:04[0m :: # never requested, and so forth.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Not all tasks are performed with the same frequency, but Redis checks for
[35m13:51:04[0m :: # tasks to perform according to the specified "hz" value.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # By default "hz" is set to 10. Raising the value will use more CPU when
[35m13:51:04[0m :: # Redis is idle, but at the same time will make Redis more responsive when
[35m13:51:04[0m :: # there are many keys expiring at the same time, and timeouts may be
[35m13:51:04[0m :: # handled with more precision.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The range is between 1 and 500, however a value over 100 is usually not
[35m13:51:04[0m :: # a good idea. Most users should use the default of 10 and raise this up to
[35m13:51:04[0m :: # 100 only in environments where very low latency is required.
[35m13:51:04[0m :: hz 10
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Normally it is useful to have an HZ value which is proportional to the
[35m13:51:04[0m :: # number of clients connected. This is useful in order, for instance, to
[35m13:51:04[0m :: # avoid too many clients are processed for each background task invocation
[35m13:51:04[0m :: # in order to avoid latency spikes.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Since the default HZ value by default is conservatively set to 10, Redis
[35m13:51:04[0m :: # offers, and enables by default, the ability to use an adaptive HZ value
[35m13:51:04[0m :: # which will temporarily raise when there are many connected clients.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # When dynamic HZ is enabled, the actual configured HZ will be used
[35m13:51:04[0m :: # as a baseline, but multiples of the configured HZ value will be actually
[35m13:51:04[0m :: # used as needed once more clients are connected. In this way an idle
[35m13:51:04[0m :: # instance will use very little CPU time while a busy instance will be
[35m13:51:04[0m :: # more responsive.
[35m13:51:04[0m :: dynamic-hz yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # When a child rewrites the AOF file, if the following option is enabled
[35m13:51:04[0m :: # the file will be fsync-ed every 32 MB of data generated. This is useful
[35m13:51:04[0m :: # in order to commit the file to the disk more incrementally and avoid
[35m13:51:04[0m :: # big latency spikes.
[35m13:51:04[0m :: aof-rewrite-incremental-fsync yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # When redis saves RDB file, if the following option is enabled
[35m13:51:04[0m :: # the file will be fsync-ed every 32 MB of data generated. This is useful
[35m13:51:04[0m :: # in order to commit the file to the disk more incrementally and avoid
[35m13:51:04[0m :: # big latency spikes.
[35m13:51:04[0m :: rdb-save-incremental-fsync yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good
[35m13:51:04[0m :: # idea to start with the default settings and only change them after investigating
[35m13:51:04[0m :: # how to improve the performances and how the keys LFU change over time, which
[35m13:51:04[0m :: # is possible to inspect via the OBJECT FREQ command.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # There are two tunable parameters in the Redis LFU implementation: the
[35m13:51:04[0m :: # counter logarithm factor and the counter decay time. It is important to
[35m13:51:04[0m :: # understand what the two parameters mean before changing them.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis
[35m13:51:04[0m :: # uses a probabilistic increment with logarithmic behavior. Given the value
[35m13:51:04[0m :: # of the old counter, when a key is accessed, the counter is incremented in
[35m13:51:04[0m :: # this way:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # 1. A random number R between 0 and 1 is extracted.
[35m13:51:04[0m :: # 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).
[35m13:51:04[0m :: # 3. The counter is incremented only if R < P.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The default lfu-log-factor is 10. This is a table of how the frequency
[35m13:51:04[0m :: # counter changes with a different number of accesses with different
[35m13:51:04[0m :: # logarithmic factors:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # +--------+------------+------------+------------+------------+------------+
[35m13:51:04[0m :: # | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
[35m13:51:04[0m :: # +--------+------------+------------+------------+------------+------------+
[35m13:51:04[0m :: # | 0      | 104        | 255        | 255        | 255        | 255        |
[35m13:51:04[0m :: # +--------+------------+------------+------------+------------+------------+
[35m13:51:04[0m :: # | 1      | 18         | 49         | 255        | 255        | 255        |
[35m13:51:04[0m :: # +--------+------------+------------+------------+------------+------------+
[35m13:51:04[0m :: # | 10     | 10         | 18         | 142        | 255        | 255        |
[35m13:51:04[0m :: # +--------+------------+------------+------------+------------+------------+
[35m13:51:04[0m :: # | 100    | 8          | 11         | 49         | 143        | 255        |
[35m13:51:04[0m :: # +--------+------------+------------+------------+------------+------------+
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # NOTE: The above table was obtained by running the following commands:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: #   redis-benchmark -n 1000000 incr foo
[35m13:51:04[0m :: #   redis-cli object freq foo
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # NOTE 2: The counter initial value is 5 in order to give new objects a chance
[35m13:51:04[0m :: # to accumulate hits.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The counter decay time is the time, in minutes, that must elapse in order
[35m13:51:04[0m :: # for the key counter to be divided by two (or decremented if it has a value
[35m13:51:04[0m :: # less <= 10).
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The default value for the lfu-decay-time is 1. A special value of 0 means to
[35m13:51:04[0m :: # decay the counter every time it happens to be scanned.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # lfu-log-factor 10
[35m13:51:04[0m :: # lfu-decay-time 1
[35m13:51:04[0m :: 
[35m13:51:04[0m :: ########################### ACTIVE DEFRAGMENTATION #######################
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # What is active defragmentation?
[35m13:51:04[0m :: # -------------------------------
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Active (online) defragmentation allows a Redis server to compact the
[35m13:51:04[0m :: # spaces left between small allocations and deallocations of data in memory,
[35m13:51:04[0m :: # thus allowing to reclaim back memory.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Fragmentation is a natural process that happens with every allocator (but
[35m13:51:04[0m :: # less so with Jemalloc, fortunately) and certain workloads. Normally a server
[35m13:51:04[0m :: # restart is needed in order to lower the fragmentation, or at least to flush
[35m13:51:04[0m :: # away all the data and create it again. However thanks to this feature
[35m13:51:04[0m :: # implemented by Oran Agra for Redis 4.0 this process can happen at runtime
[35m13:51:04[0m :: # in a "hot" way, while the server is running.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Basically when the fragmentation is over a certain level (see the
[35m13:51:04[0m :: # configuration options below) Redis will start to create new copies of the
[35m13:51:04[0m :: # values in contiguous memory regions by exploiting certain specific Jemalloc
[35m13:51:04[0m :: # features (in order to understand if an allocation is causing fragmentation
[35m13:51:04[0m :: # and to allocate it in a better place), and at the same time, will release the
[35m13:51:04[0m :: # old copies of the data. This process, repeated incrementally for all the keys
[35m13:51:04[0m :: # will cause the fragmentation to drop back to normal values.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Important things to understand:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # 1. This feature is disabled by default, and only works if you compiled Redis
[35m13:51:04[0m :: #    to use the copy of Jemalloc we ship with the source code of Redis.
[35m13:51:04[0m :: #    This is the default with Linux builds.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # 2. You never need to enable this feature if you don't have fragmentation
[35m13:51:04[0m :: #    issues.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # 3. Once you experience fragmentation, you can enable this feature when
[35m13:51:04[0m :: #    needed with the command "CONFIG SET activedefrag yes".
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # The configuration parameters are able to fine tune the behavior of the
[35m13:51:04[0m :: # defragmentation process. If you are not sure about what they mean it is
[35m13:51:04[0m :: # a good idea to leave the defaults untouched.
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Enabled active defragmentation
[35m13:51:04[0m :: # NOTE: This feature is not available in the stock Debian packages as they use
[35m13:51:04[0m :: # the distribution-wide jemalloc allocator that does not have support for active
[35m13:51:04[0m :: # defragmentation. See #967970 for more information.
[35m13:51:04[0m :: # activedefrag no
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Minimum amount of fragmentation waste to start active defrag
[35m13:51:04[0m :: # active-defrag-ignore-bytes 100mb
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Minimum percentage of fragmentation to start active defrag
[35m13:51:04[0m :: # active-defrag-threshold-lower 10
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Maximum percentage of fragmentation at which we use maximum effort
[35m13:51:04[0m :: # active-defrag-threshold-upper 100
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Minimal effort for defrag in CPU percentage, to be used when the lower
[35m13:51:04[0m :: # threshold is reached
[35m13:51:04[0m :: # active-defrag-cycle-min 1
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Maximal effort for defrag in CPU percentage, to be used when the upper
[35m13:51:04[0m :: # threshold is reached
[35m13:51:04[0m :: # active-defrag-cycle-max 25
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Maximum number of set/hash/zset/list fields that will be processed from
[35m13:51:04[0m :: # the main dictionary scan
[35m13:51:04[0m :: # active-defrag-max-scan-fields 1000
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # Jemalloc background thread for purging will be enabled by default
[35m13:51:04[0m :: jemalloc-bg-thread yes
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # It is possible to pin different threads and processes of Redis to specific
[35m13:51:04[0m :: # CPUs in your system, in order to maximize the performances of the server.
[35m13:51:04[0m :: # This is useful both in order to pin different Redis threads in different
[35m13:51:04[0m :: # CPUs, but also in order to make sure that multiple Redis instances running
[35m13:51:04[0m :: # in the same host will be pinned to different CPUs.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Normally you can do this using the "taskset" command, however it is also
[35m13:51:04[0m :: # possible to this via Redis configuration directly, both in Linux and FreeBSD.
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # You can pin the server/IO threads, bio threads, aof rewrite child process, and
[35m13:51:04[0m :: # the bgsave child process. The syntax to specify the cpu list is the same as
[35m13:51:04[0m :: # the taskset command:
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Set redis server/io threads to cpu affinity 0,2,4,6:
[35m13:51:04[0m :: # server_cpulist 0-7:2
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Set bio threads to cpu affinity 1,3:
[35m13:51:04[0m :: # bio_cpulist 1,3
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Set aof rewrite child process to cpu affinity 8,9,10,11:
[35m13:51:04[0m :: # aof_rewrite_cpulist 8-11
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # Set bgsave child process to cpu affinity 1,10,11
[35m13:51:04[0m :: # bgsave_cpulist 1,10-11
[35m13:51:04[0m :: 
[35m13:51:04[0m :: # In some cases redis will emit warnings and even refuse to start if it detects
[35m13:51:04[0m :: # that the system is in bad state, it is possible to suppress these warnings
[35m13:51:04[0m :: # by setting the following config which takes a space delimited list of warnings
[35m13:51:04[0m :: # to suppress
[35m13:51:04[0m :: #
[35m13:51:04[0m :: # ignore-warnings ARM64-COW-BUG
[1;36m[task check][0m
stdout match <^^ (\x[23]) \s requirepass \s> [36mTrue[0m
[1;36m[task run: task.bash - tasks/redis][0m
[1;36m[task stdout][0m
[1;36m[task run: task.bash - tasks/redis][0m
[1;36m[task stdout][0m
[35m13:51:06[0m :: NOAUTH Authentication required.
[35m13:51:06[0m :: 
[1;36m[task check][0m
stdout match <NOAUTH Authentication required> [36mTrue[0m

Script done on 2025-12-24 13:51:06+03:00 [COMMAND_EXIT_CODE="0"]
